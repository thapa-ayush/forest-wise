{% extends 'base.html' %}
{% block content %}
<!-- Page Header -->
<div class="flex items-center justify-between mb-6">
    <div>
        <h1 class="text-2xl font-bold text-white flex items-center gap-3">
            <svg class="w-7 h-7 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
            </svg>
            Live Map
            <span class="text-xs px-2 py-1 rounded-full bg-blue-500/20 text-blue-400">Azure Maps</span>
        </h1>
        <p class="text-gray-400 text-sm mt-1">Real-time view of nodes and alerts</p>
    </div>
    <div class="flex items-center gap-3">
        <!-- Map Legend -->
        <div class="flex items-center gap-4 text-sm">
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-emerald-500"></div>
                <span class="text-gray-400">Online</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-gray-500"></div>
                <span class="text-gray-400">Offline</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-red-500"></div>
                <span class="text-gray-400">Alerts</span>
            </div>
        </div>
        <button id="center-map" class="btn btn-secondary text-sm">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4" />
            </svg>
            Center
        </button>
    </div>
</div>

<!-- Map Container -->
<div class="card overflow-hidden relative">
    <!-- Azure Maps CSS -->
    <link rel="stylesheet" href="https://atlas.microsoft.com/sdk/javascript/mapcontrol/3/atlas.min.css" type="text/css">
    <div id="map" class="w-full h-[600px]"></div>

    <!-- Empty state overlay -->
    <div id="empty-state"
        class="absolute inset-0 flex items-center justify-center bg-gray-900/80 hidden pointer-events-none z-10">
        <div class="text-center">
            <svg class="w-12 h-12 text-gray-500 mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
            <p class="text-gray-400">No nodes with valid GPS coordinates</p>
            <p class="text-gray-500 text-sm mt-1">Waiting for GPS lock on guardian nodes...</p>
        </div>
    </div>

    <!-- Azure Maps Key Missing Warning -->
    <div id="api-key-warning" class="absolute inset-0 flex items-center justify-center bg-gray-900/90 hidden z-20">
        <div class="text-center p-6 max-w-md">
            <svg class="w-16 h-16 text-yellow-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
            </svg>
            <h3 class="text-xl font-bold text-white mb-2">Azure Maps Key Required</h3>
            <p class="text-gray-400 mb-4">Please add your Azure Maps subscription key to the .env file:</p>
            <code class="block bg-gray-800 text-cyan-400 p-3 rounded text-sm mb-4">AZURE_MAPS_KEY=your-key-here</code>
            <p class="text-gray-500 text-sm">Get your key from the <a
                    href="https://portal.azure.com/#create/Microsoft.Maps" target="_blank"
                    class="text-cyan-400 hover:underline">Azure Portal</a></p>
        </div>
    </div>
</div>

<!-- Info Panel -->
<div id="info-panel" class="fixed bottom-6 right-6 w-80 card hidden z-[1000]">
    <div class="p-4">
        <div class="flex items-center justify-between mb-3">
            <h3 id="panel-title" class="font-semibold text-white">Details</h3>
            <button id="close-panel" class="text-gray-400 hover:text-white">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
        </div>
        <div id="panel-content" class="text-sm text-gray-300">
            <!-- Dynamic content -->
        </div>
    </div>
</div>

<!-- Azure Maps SDK -->
<script src="https://atlas.microsoft.com/sdk/javascript/mapcontrol/3/atlas.min.js"></script>
<script>
    // Azure Maps Key from backend
    const AZURE_MAPS_KEY = '{{ config.AZURE_MAPS_KEY or "" }}';

    let map = null;
    let datasource = null;
    let nodeLayer = null;
    let alertLayer = null;
    let popup = null;

    // Check if key is configured
    if (!AZURE_MAPS_KEY) {
        document.getElementById('api-key-warning').classList.remove('hidden');
    } else {
        initMap();
    }

    function initMap() {
        // Initialize Azure Map
        map = new atlas.Map('map', {
            center: [-79.38, 43.65], // Toronto default [lon, lat]
            zoom: 10,
            style: 'night', // Dark theme
            language: 'en-US',
            authOptions: {
                authType: 'subscriptionKey',
                subscriptionKey: AZURE_MAPS_KEY
            }
        });

        // Wait for map to be ready
        map.events.add('ready', function () {
            // Create data source for markers
            datasource = new atlas.source.DataSource();
            map.sources.add(datasource);

            // Create popup
            popup = new atlas.Popup({
                pixelOffset: [0, -30],
                closeButton: true
            });

            // Node layer - use different colors based on online status
            nodeLayer = new atlas.layer.SymbolLayer(datasource, 'nodeLayer', {
                filter: ['==', ['get', 'type'], 'node'],
                iconOptions: {
                    // Use marker-green for online, marker-gray for offline
                    image: ['case',
                        ['get', 'isOnline'], 'marker-green',
                        'marker-gray'
                    ],
                    size: 0.8,
                    allowOverlap: true
                }
            });

            // Alert layer (red pulsing circles)
            alertLayer = new atlas.layer.BubbleLayer(datasource, 'alertLayer', {
                filter: ['==', ['get', 'type'], 'alert'],
                color: '#ef4444',
                radius: 15,
                strokeColor: '#ffffff',
                strokeWidth: 2,
                opacity: 0.8
            });

            // Add custom marker images
            map.imageSprite.createFromTemplate('marker-green', 'marker', '#10b981', '#ffffff');
            map.imageSprite.createFromTemplate('marker-gray', 'marker', '#6b7280', '#ffffff');
            map.imageSprite.createFromTemplate('marker-red', 'marker', '#ef4444', '#ffffff');

            map.layers.add([alertLayer, nodeLayer]);

            // Add click events
            map.events.add('click', nodeLayer, onNodeClick);
            map.events.add('click', alertLayer, onAlertClick);

            // Change cursor on hover
            map.events.add('mousemove', nodeLayer, () => map.getCanvasContainer().style.cursor = 'pointer');
            map.events.add('mouseleave', nodeLayer, () => map.getCanvasContainer().style.cursor = 'grab');
            map.events.add('mousemove', alertLayer, () => map.getCanvasContainer().style.cursor = 'pointer');
            map.events.add('mouseleave', alertLayer, () => map.getCanvasContainer().style.cursor = 'grab');

            // Load initial data
            loadNodes();
            loadAlerts();
        });
    }

    // Node click handler
    function onNodeClick(e) {
        if (e.shapes && e.shapes.length > 0) {
            const props = e.shapes[0].getProperties();
            showNodeInfo(props.data);
        }
    }

    // Alert click handler
    function onAlertClick(e) {
        if (e.shapes && e.shapes.length > 0) {
            const props = e.shapes[0].getProperties();
            if (props.count > 1) {
                showGroupedAlertInfo(props.alerts);
            } else {
                showAlertInfo(props.alerts[0]);
            }
        }
    }

    // Info panel functions
    const infoPanel = document.getElementById('info-panel');
    const panelTitle = document.getElementById('panel-title');
    const panelContent = document.getElementById('panel-content');

    function showNodeInfo(node) {
        panelTitle.textContent = node.node_id;
        const isOnline = node.is_online === true;
        const lastSeen = node.last_seen ? new Date(node.last_seen).toLocaleString() : 'Unknown';
        panelContent.innerHTML = `
            <div class="space-y-2">
                <div class="flex justify-between">
                    <span class="text-gray-400">Status</span>
                    <span class="status-badge ${isOnline ? 'online' : 'offline'}">
                        <span class="status-dot"></span>
                        ${isOnline ? 'Online' : 'Offline'}
                    </span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Battery</span>
                    <span class="${node.battery > 50 ? 'text-emerald-400' : node.battery > 20 ? 'text-yellow-400' : 'text-red-400'}">${node.battery || 0}%</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Location</span>
                    <span class="font-mono">${(node.lat || 0).toFixed(4)}, ${(node.lon || 0).toFixed(4)}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Signal</span>
                    <span class="${node.rssi > -70 ? 'text-emerald-400' : node.rssi > -90 ? 'text-yellow-400' : 'text-red-400'}">${node.rssi || 0} dBm</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Last Seen</span>
                    <span>${lastSeen}</span>
                </div>
            </div>
            <a href="/nodes" class="btn btn-secondary w-full mt-4 text-center text-sm">View All Nodes</a>
        `;
        infoPanel.classList.remove('hidden');
    }

    function showAlertInfo(alert) {
        panelTitle.textContent = 'Alert #' + alert.id;
        const date = new Date(alert.timestamp);
        panelContent.innerHTML = `
            <div class="space-y-2">
                <div class="flex justify-between">
                    <span class="text-gray-400">Node</span>
                    <span class="font-semibold">${alert.node_id}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Confidence</span>
                    <span class="${alert.confidence >= 70 ? 'text-red-400' : 'text-yellow-400'} font-bold">${alert.confidence}%</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Location</span>
                    <span class="font-mono">${(alert.lat || 0).toFixed(4)}, ${(alert.lon || 0).toFixed(4)}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Time</span>
                    <span>${date.toLocaleString()}</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Status</span>
                    <span class="status-badge ${alert.responded ? 'online' : 'offline'}">
                        <span class="status-dot"></span>
                        ${alert.responded ? 'Responded' : 'Pending'}
                    </span>
                </div>
            </div>
            <a href="/alerts" class="btn btn-primary w-full mt-4 text-center text-sm">View All Alerts</a>
        `;
        infoPanel.classList.remove('hidden');
    }

    function showGroupedAlertInfo(alerts) {
        panelTitle.textContent = `${alerts.length} Alerts at Location`;
        let alertsList = alerts.slice(0, 5).map(a => {
            const date = new Date(a.timestamp);
            return `<div class="flex justify-between py-1 border-b border-gray-700">
                <span class="text-gray-400">#${a.id}</span>
                <span class="${a.confidence >= 70 ? 'text-red-400' : 'text-yellow-400'} font-bold">${a.confidence}%</span>
                <span class="text-xs text-gray-500">${date.toLocaleTimeString()}</span>
            </div>`;
        }).join('');

        if (alerts.length > 5) {
            alertsList += `<div class="text-center text-gray-500 text-sm mt-2">+${alerts.length - 5} more...</div>`;
        }

        panelContent.innerHTML = `
            <div class="space-y-1 max-h-48 overflow-y-auto">
                ${alertsList}
            </div>
            <div class="flex justify-between mt-3 pt-2 border-t border-gray-700">
                <span class="text-gray-400">Node</span>
                <span class="font-semibold">${alerts[0].node_id}</span>
            </div>
            <div class="flex justify-between">
                <span class="text-gray-400">Location</span>
                <span class="font-mono text-xs">${alerts[0].lat.toFixed(4)}, ${alerts[0].lon.toFixed(4)}</span>
            </div>
            <a href="/alerts" class="btn btn-primary w-full mt-4 text-center text-sm">View All Alerts</a>
        `;
        infoPanel.classList.remove('hidden');
    }

    document.getElementById('close-panel').addEventListener('click', () => {
        infoPanel.classList.add('hidden');
    });

    // Helper to check if coordinates are valid
    function isValidCoords(lat, lon) {
        if (!lat || !lon) return false;
        if (Math.abs(lat) < 1 && Math.abs(lon) < 1) return false;
        if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return false;
        return true;
    }

    // Load nodes from API
    function loadNodes() {
        if (!map || !datasource) return;

        fetch('/api/nodes').then(r => r.json()).then(nodes => {
            // Remove old node features
            const features = datasource.getShapes();
            features.forEach(f => {
                if (f.getProperties().type === 'node') {
                    datasource.remove(f);
                }
            });

            let validNodes = [];
            nodes.forEach(n => {
                if (isValidCoords(n.lat, n.lon)) {
                    // Check if node is online (is_online boolean from API)
                    const isOnline = n.is_online === true;
                    // Azure Maps uses [longitude, latitude]
                    const feature = new atlas.data.Feature(
                        new atlas.data.Point([n.lon, n.lat]),
                        {
                            type: 'node',
                            data: n,
                            title: n.node_id,
                            isOnline: isOnline
                        }
                    );
                    datasource.add(feature);
                    validNodes.push(n);
                }
            });

            // Center map on first valid node
            if (validNodes.length > 0 && !window.mapCentered) {
                map.setCamera({
                    center: [validNodes[0].lon, validNodes[0].lat],
                    zoom: 12
                });
                window.mapCentered = true;
            }

            updateEmptyState();
        }).catch(err => console.error('Error loading nodes:', err));
    }

    // Load alerts from API
    function loadAlerts() {
        if (!map || !datasource) return;

        fetch('/api/alerts?unresponded=true').then(r => r.json()).then(alerts => {
            // Remove old alert features
            const features = datasource.getShapes();
            features.forEach(f => {
                if (f.getProperties().type === 'alert') {
                    datasource.remove(f);
                }
            });

            // Filter valid coordinates
            const validAlerts = alerts.filter(a => isValidCoords(a.lat, a.lon));

            // Group alerts by location
            const grouped = groupAlertsByLocation(validAlerts, 0.001);

            grouped.forEach(group => {
                const feature = new atlas.data.Feature(
                    new atlas.data.Point([group.lon, group.lat]),
                    {
                        type: 'alert',
                        count: group.alerts.length,
                        alerts: group.alerts,
                        maxConfidence: Math.max(...group.alerts.map(a => a.confidence))
                    }
                );
                datasource.add(feature);
            });

            updateEmptyState();
        }).catch(err => console.error('Error loading alerts:', err));
    }

    // Group alerts by location proximity
    function groupAlertsByLocation(alerts, threshold) {
        const groups = [];
        const used = new Set();

        alerts.forEach((alert, i) => {
            if (used.has(i)) return;

            const group = {
                lat: alert.lat,
                lon: alert.lon,
                alerts: [alert]
            };
            used.add(i);

            alerts.forEach((other, j) => {
                if (used.has(j)) return;
                const dist = Math.sqrt(
                    Math.pow(alert.lat - other.lat, 2) +
                    Math.pow(alert.lon - other.lon, 2)
                );
                if (dist < threshold) {
                    group.alerts.push(other);
                    used.add(j);
                }
            });

            groups.push(group);
        });

        return groups;
    }

    // Show/hide empty state
    function updateEmptyState() {
        if (!datasource) return;
        const emptyState = document.getElementById('empty-state');
        const features = datasource.getShapes();
        if (features.length === 0) {
            emptyState.classList.remove('hidden');
        } else {
            emptyState.classList.add('hidden');
        }
    }

    // Center map on nodes - prioritize online nodes
    document.getElementById('center-map').addEventListener('click', () => {
        if (!map || !datasource) return;

        const shapes = datasource.getShapes();

        // Get node shapes only (not alerts)
        const nodeShapes = shapes.filter(s => s.getProperties().type === 'node');

        if (nodeShapes.length === 0) return;

        // Separate online and offline nodes
        const onlineNodes = nodeShapes.filter(s => s.getProperties().isOnline === true);
        const offlineNodes = nodeShapes.filter(s => s.getProperties().isOnline !== true);

        // Use online nodes if any exist, otherwise use offline nodes
        const targetNodes = onlineNodes.length > 0 ? onlineNodes : offlineNodes;

        if (targetNodes.length > 0) {
            if (targetNodes.length === 1) {
                // Single node - center and zoom
                const coords = targetNodes[0].getCoordinates();
                map.setCamera({
                    center: coords,
                    zoom: 14
                });
            } else {
                // Multiple nodes - fit bounds
                const bounds = atlas.data.BoundingBox.fromData(
                    targetNodes.map(s => s.getCoordinates())
                );
                map.setCamera({
                    bounds: bounds,
                    padding: 50
                });
            }
        }
    });

    // Check URL params for focusing on specific location
    const urlParams = new URLSearchParams(window.location.search);
    const focusLat = urlParams.get('lat');
    const focusLon = urlParams.get('lon');
    if (focusLat && focusLon && map) {
        map.setCamera({
            center: [parseFloat(focusLon), parseFloat(focusLat)],
            zoom: 15
        });
        window.mapCentered = true;
    }

    // Real-time updates
    if (typeof socket !== 'undefined') {
        socket.on('node_update', () => loadNodes());
        socket.on('new_alert', () => loadAlerts());
    }

    // Refresh every 30 seconds
    setInterval(() => {
        loadNodes();
        loadAlerts();
    }, 30000);
</script>

<style>
    /* Azure Maps customizations */
    .atlas-map {
        font-family: inherit;
    }

    .atlas-map .mapboxgl-ctrl-attrib {
        background: rgba(17, 24, 39, 0.8) !important;
        color: #9ca3af !important;
    }

    .atlas-map .mapboxgl-ctrl-attrib a {
        color: #60a5fa !important;
    }
</style>
{% endblock %}